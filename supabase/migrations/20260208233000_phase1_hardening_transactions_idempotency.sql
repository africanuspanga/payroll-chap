-- Phase 1 hardening: transactional RPCs, idempotency, and structured error events

create table if not exists public.idempotency_requests (
  id uuid primary key default gen_random_uuid(),
  company_id uuid not null references public.companies(id) on delete cascade,
  endpoint text not null,
  idempotency_key text not null,
  request_hash text not null,
  status text not null default 'in_progress',
  response_code integer,
  response_body jsonb,
  error_body jsonb,
  created_by uuid references auth.users(id),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  check (status in ('in_progress', 'completed', 'failed')),
  unique (company_id, endpoint, idempotency_key)
);

create index if not exists idx_idempotency_requests_company_created
  on public.idempotency_requests (company_id, created_at desc);

drop trigger if exists trg_idempotency_requests_updated_at on public.idempotency_requests;
create trigger trg_idempotency_requests_updated_at
before update on public.idempotency_requests
for each row execute procedure public.set_updated_at();

alter table public.idempotency_requests enable row level security;

drop policy if exists idempotency_requests_select_member on public.idempotency_requests;
create policy idempotency_requests_select_member
on public.idempotency_requests
for select
using (public.is_company_member(company_id));

drop policy if exists idempotency_requests_insert_operator on public.idempotency_requests;
create policy idempotency_requests_insert_operator
on public.idempotency_requests
for insert
with check (public.has_company_role(company_id, array['owner','admin','accountant']::public.app_role[]));

drop policy if exists idempotency_requests_update_operator on public.idempotency_requests;
create policy idempotency_requests_update_operator
on public.idempotency_requests
for update
using (public.has_company_role(company_id, array['owner','admin','accountant']::public.app_role[]))
with check (public.has_company_role(company_id, array['owner','admin','accountant']::public.app_role[]));

create table if not exists public.system_error_events (
  id bigint generated by default as identity primary key,
  company_id uuid references public.companies(id) on delete set null,
  actor_user_id uuid references auth.users(id) on delete set null,
  category text not null,
  severity text not null default 'error',
  route text,
  method text,
  status_code integer,
  message text not null,
  details jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  check (severity in ('info', 'warn', 'error', 'critical'))
);

create index if not exists idx_system_error_events_company_created
  on public.system_error_events (company_id, created_at desc);

create index if not exists idx_system_error_events_category_created
  on public.system_error_events (category, created_at desc);

alter table public.system_error_events enable row level security;

drop policy if exists system_error_events_select_member on public.system_error_events;
create policy system_error_events_select_member
on public.system_error_events
for select
using (
  actor_user_id = auth.uid()
  or (
    company_id is not null
    and public.has_company_role(company_id, array['owner','admin']::public.app_role[])
  )
);

drop policy if exists system_error_events_insert_authenticated on public.system_error_events;
create policy system_error_events_insert_authenticated
on public.system_error_events
for insert
to authenticated
with check (
  (actor_user_id is null or actor_user_id = auth.uid())
  and (company_id is null or public.is_company_member(company_id))
);

create or replace function public.tx_create_employee_with_contract(
  p_company_id uuid,
  p_actor_user_id uuid,
  p_employee jsonb,
  p_contract jsonb
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_employee_id uuid;
begin
  if auth.uid() is null then
    raise exception 'Authentication required';
  end if;

  if p_actor_user_id is null or auth.uid() <> p_actor_user_id then
    raise exception 'Actor mismatch';
  end if;

  if not public.has_company_role(p_company_id, array['owner','admin','accountant']::public.app_role[]) then
    raise exception 'Permission denied';
  end if;

  insert into public.employees (
    company_id,
    employee_no,
    first_name,
    last_name,
    work_email,
    phone,
    hire_date,
    employment_type,
    tax_residency,
    is_primary_employment,
    is_non_full_time_director,
    payment_method,
    bank_name,
    bank_account_no,
    mobile_money_provider,
    mobile_money_no,
    metadata
  )
  values (
    p_company_id,
    nullif(p_employee->>'employee_no', ''),
    p_employee->>'first_name',
    p_employee->>'last_name',
    nullif(p_employee->>'work_email', ''),
    nullif(p_employee->>'phone', ''),
    (p_employee->>'hire_date')::date,
    coalesce(nullif(p_employee->>'employment_type', ''), 'permanent'),
    coalesce(nullif(p_employee->>'tax_residency', ''), 'resident'),
    coalesce((p_employee->>'is_primary_employment')::boolean, true),
    coalesce((p_employee->>'is_non_full_time_director')::boolean, false),
    coalesce(nullif(p_employee->>'payment_method', ''), 'bank'),
    nullif(p_employee->>'bank_name', ''),
    nullif(p_employee->>'bank_account_no', ''),
    nullif(p_employee->>'mobile_money_provider', ''),
    nullif(p_employee->>'mobile_money_no', ''),
    coalesce(p_employee->'metadata', '{}'::jsonb)
  )
  returning id into v_employee_id;

  insert into public.employee_contracts (
    company_id,
    employee_id,
    contract_type,
    effective_from,
    basic_salary,
    salary_frequency,
    currency_code,
    metadata
  )
  values (
    p_company_id,
    v_employee_id,
    coalesce(nullif(p_contract->>'contract_type', ''), 'permanent'),
    (p_contract->>'effective_from')::date,
    coalesce((p_contract->>'basic_salary')::numeric, 0),
    coalesce(nullif(p_contract->>'salary_frequency', ''), 'monthly'),
    coalesce(nullif(p_contract->>'currency_code', ''), 'TZS'),
    coalesce(p_contract->'metadata', '{}'::jsonb)
  );

  insert into public.audit_events (
    company_id,
    actor_user_id,
    action,
    entity_type,
    entity_id,
    metadata
  )
  values (
    p_company_id,
    p_actor_user_id,
    'employee.created',
    'employee',
    v_employee_id::text,
    jsonb_build_object(
      'fullName',
      concat_ws(' ', p_employee->>'first_name', p_employee->>'last_name')
    )
  );

  return v_employee_id;
end;
$$;

revoke all on function public.tx_create_employee_with_contract(uuid, uuid, jsonb, jsonb) from public;
grant execute on function public.tx_create_employee_with_contract(uuid, uuid, jsonb, jsonb) to authenticated;

create or replace function public.tx_create_payroll_run_with_items(
  p_company_id uuid,
  p_actor_user_id uuid,
  p_payroll_period_id uuid,
  p_run_label text,
  p_gross_total numeric,
  p_deduction_total numeric,
  p_net_total numeric,
  p_rule_set_id uuid,
  p_rule_version integer,
  p_items jsonb
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_payroll_run_id uuid;
  v_item_count integer;
begin
  if auth.uid() is null then
    raise exception 'Authentication required';
  end if;

  if p_actor_user_id is null or auth.uid() <> p_actor_user_id then
    raise exception 'Actor mismatch';
  end if;

  if not public.has_company_role(p_company_id, array['owner','admin','accountant']::public.app_role[]) then
    raise exception 'Permission denied';
  end if;

  if jsonb_typeof(coalesce(p_items, '[]'::jsonb)) <> 'array' then
    raise exception 'p_items must be a JSON array';
  end if;

  if jsonb_array_length(coalesce(p_items, '[]'::jsonb)) = 0 then
    raise exception 'p_items must contain at least one item';
  end if;

  insert into public.payroll_runs (
    company_id,
    payroll_period_id,
    run_label,
    status,
    gross_total,
    deduction_total,
    net_total,
    created_by
  )
  values (
    p_company_id,
    p_payroll_period_id,
    coalesce(nullif(p_run_label, ''), 'main'),
    'draft',
    coalesce(p_gross_total, 0),
    coalesce(p_deduction_total, 0),
    coalesce(p_net_total, 0),
    p_actor_user_id
  )
  returning id into v_payroll_run_id;

  insert into public.payroll_run_items (
    company_id,
    payroll_run_id,
    employee_id,
    gross_pay,
    taxable_pay,
    total_deductions,
    net_pay,
    calc_snapshot
  )
  select
    p_company_id,
    v_payroll_run_id,
    (row->>'employee_id')::uuid,
    coalesce((row->>'gross_pay')::numeric, 0),
    coalesce((row->>'taxable_pay')::numeric, 0),
    coalesce((row->>'total_deductions')::numeric, 0),
    coalesce((row->>'net_pay')::numeric, 0),
    coalesce(row->'calc_snapshot', '{}'::jsonb)
  from jsonb_array_elements(p_items) row;

  get diagnostics v_item_count = row_count;

  insert into public.audit_events (
    company_id,
    actor_user_id,
    action,
    entity_type,
    entity_id,
    metadata
  )
  values (
    p_company_id,
    p_actor_user_id,
    'payroll_run.draft_created',
    'payroll_run',
    v_payroll_run_id::text,
    jsonb_build_object(
      'employeeCount', v_item_count,
      'grossTotal', coalesce(p_gross_total, 0),
      'netTotal', coalesce(p_net_total, 0),
      'ruleSetId', p_rule_set_id,
      'ruleVersion', p_rule_version
    )
  );

  return v_payroll_run_id;
end;
$$;

revoke all on function public.tx_create_payroll_run_with_items(uuid, uuid, uuid, text, numeric, numeric, numeric, uuid, integer, jsonb) from public;
grant execute on function public.tx_create_payroll_run_with_items(uuid, uuid, uuid, text, numeric, numeric, numeric, uuid, integer, jsonb) to authenticated;

create or replace function public.tx_generate_filing_batch_with_reminders(
  p_company_id uuid,
  p_actor_user_id uuid,
  p_payroll_period_id uuid,
  p_payroll_run_id uuid,
  p_rule_set_id uuid,
  p_rule_version integer,
  p_filings jsonb,
  p_reminders jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_filings jsonb := coalesce(p_filings, '[]'::jsonb);
  v_reminders jsonb := coalesce(p_reminders, '[]'::jsonb);
  v_inserted jsonb := '[]'::jsonb;
  v_type text;
begin
  if auth.uid() is null then
    raise exception 'Authentication required';
  end if;

  if p_actor_user_id is null or auth.uid() <> p_actor_user_id then
    raise exception 'Actor mismatch';
  end if;

  if not public.has_company_role(p_company_id, array['owner','admin','accountant']::public.app_role[]) then
    raise exception 'Permission denied';
  end if;

  if jsonb_typeof(v_filings) <> 'array' or jsonb_array_length(v_filings) = 0 then
    raise exception 'p_filings must be a non-empty JSON array';
  end if;

  perform pg_advisory_xact_lock(hashtext(p_company_id::text), hashtext(p_payroll_period_id::text));

  for v_type in
    select distinct row->>'filing_type'
    from jsonb_array_elements(v_filings) row
  loop
    if exists (
      select 1
      from public.filing_returns fr
      where fr.company_id = p_company_id
        and fr.payroll_period_id = p_payroll_period_id
        and fr.original_filing_id is null
        and fr.filing_type = v_type
    ) then
      raise exception 'Base filings already exist for this payroll period. Use amend workflow instead.';
    end if;
  end loop;

  with inserted as (
    insert into public.filing_returns (
      company_id,
      payroll_period_id,
      filing_type,
      due_date,
      status,
      amount_due,
      penalty_amount,
      interest_amount,
      metadata
    )
    select
      p_company_id,
      p_payroll_period_id,
      row->>'filing_type',
      (row->>'due_date')::date,
      coalesce(nullif(row->>'status', '')::public.filing_status, 'ready'::public.filing_status),
      coalesce((row->>'amount_due')::numeric, 0),
      coalesce((row->>'penalty_amount')::numeric, 0),
      coalesce((row->>'interest_amount')::numeric, 0),
      coalesce(row->'metadata', '{}'::jsonb)
    from jsonb_array_elements(v_filings) row
    returning id, filing_type, due_date, amount_due, penalty_amount, status
  )
  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'filing_type', filing_type,
        'due_date', due_date,
        'amount_due', amount_due,
        'penalty_amount', penalty_amount,
        'status', status
      )
    ),
    '[]'::jsonb
  )
  into v_inserted
  from inserted;

  if jsonb_typeof(v_reminders) = 'array' and jsonb_array_length(v_reminders) > 0 then
    insert into public.compliance_reminders (
      company_id,
      reminder_type,
      due_date,
      status,
      related_entity_type,
      related_entity_id
    )
    select
      p_company_id,
      row->>'reminder_type',
      (row->>'due_date')::date,
      coalesce(nullif(row->>'status', ''), 'open'),
      row->>'related_entity_type',
      row->>'related_entity_id'
    from jsonb_array_elements(v_reminders) row
    where row ? 'reminder_type'
      and row ? 'due_date'
      and row ? 'related_entity_type'
      and row ? 'related_entity_id'
    on conflict (company_id, reminder_type, due_date, related_entity_type, related_entity_id)
    do update set status = excluded.status;
  end if;

  insert into public.audit_events (
    company_id,
    actor_user_id,
    action,
    entity_type,
    entity_id,
    metadata
  )
  values (
    p_company_id,
    p_actor_user_id,
    'filing.generated',
    'filing_batch',
    p_payroll_run_id::text,
    jsonb_build_object(
      'filings', v_inserted,
      'ruleSetId', p_rule_set_id,
      'ruleVersion', p_rule_version
    )
  );

  return jsonb_build_object('filings', v_inserted);
end;
$$;

revoke all on function public.tx_generate_filing_batch_with_reminders(uuid, uuid, uuid, uuid, uuid, integer, jsonb, jsonb) from public;
grant execute on function public.tx_generate_filing_batch_with_reminders(uuid, uuid, uuid, uuid, uuid, integer, jsonb, jsonb) to authenticated;
