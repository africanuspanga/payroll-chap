-- Step 3: Multi-tenant security baseline for Payroll Chap (Supabase)

create extension if not exists pgcrypto;

do $$
begin
  if not exists (select 1 from pg_type where typname = 'app_role' and typnamespace = 'public'::regnamespace) then
    create type public.app_role as enum ('owner', 'admin', 'accountant', 'employee');
  end if;
end;
$$;

create table if not exists public.companies (
  id uuid primary key default gen_random_uuid(),
  legal_name text not null,
  trade_name text,
  country_code text not null default 'TZ',
  currency_code text not null default 'TZS',
  timezone text not null default 'Africa/Dar_es_Salaam',
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.user_profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  phone text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.company_memberships (
  id uuid primary key default gen_random_uuid(),
  company_id uuid not null references public.companies(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role public.app_role not null,
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (company_id, user_id)
);

create index if not exists idx_company_memberships_user_id on public.company_memberships (user_id);
create index if not exists idx_company_memberships_company_id on public.company_memberships (company_id);

create table if not exists public.audit_events (
  id bigint generated by default as identity primary key,
  company_id uuid not null references public.companies(id) on delete cascade,
  actor_user_id uuid references auth.users(id),
  action text not null,
  entity_type text not null,
  entity_id text not null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_audit_events_company_id_created_at
  on public.audit_events (company_id, created_at desc);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$;

drop trigger if exists trg_companies_updated_at on public.companies;
create trigger trg_companies_updated_at
before update on public.companies
for each row execute procedure public.set_updated_at();

drop trigger if exists trg_user_profiles_updated_at on public.user_profiles;
create trigger trg_user_profiles_updated_at
before update on public.user_profiles
for each row execute procedure public.set_updated_at();

drop trigger if exists trg_company_memberships_updated_at on public.company_memberships;
create trigger trg_company_memberships_updated_at
before update on public.company_memberships
for each row execute procedure public.set_updated_at();

create or replace function public.is_company_member(p_company_id uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.company_memberships m
    where m.company_id = p_company_id
      and m.user_id = auth.uid()
      and m.is_active = true
  );
$$;

create or replace function public.has_company_role(p_company_id uuid, p_roles public.app_role[])
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.company_memberships m
    where m.company_id = p_company_id
      and m.user_id = auth.uid()
      and m.is_active = true
      and m.role = any (p_roles)
  );
$$;

create or replace function public.create_company_with_owner(
  p_legal_name text,
  p_trade_name text default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_company_id uuid;
begin
  if auth.uid() is null then
    raise exception 'Authentication required';
  end if;

  insert into public.companies (legal_name, trade_name)
  values (p_legal_name, p_trade_name)
  returning id into v_company_id;

  insert into public.company_memberships (company_id, user_id, role)
  values (v_company_id, auth.uid(), 'owner');

  insert into public.user_profiles (user_id)
  values (auth.uid())
  on conflict (user_id) do nothing;

  return v_company_id;
end;
$$;

alter table public.companies enable row level security;
alter table public.user_profiles enable row level security;
alter table public.company_memberships enable row level security;
alter table public.audit_events enable row level security;

-- companies policies
create policy companies_select_member
on public.companies
for select
using (public.is_company_member(id));

create policy companies_insert_authenticated
on public.companies
for insert
to authenticated
with check (true);

create policy companies_update_owner_admin
on public.companies
for update
using (public.has_company_role(id, array['owner', 'admin']::public.app_role[]))
with check (public.has_company_role(id, array['owner', 'admin']::public.app_role[]));

-- user_profiles policies
create policy user_profiles_select_self
on public.user_profiles
for select
using (user_id = auth.uid());

create policy user_profiles_upsert_self
on public.user_profiles
for all
using (user_id = auth.uid())
with check (user_id = auth.uid());

-- company_memberships policies
create policy company_memberships_select_self_or_admin
on public.company_memberships
for select
using (
  user_id = auth.uid()
  or public.has_company_role(company_id, array['owner', 'admin']::public.app_role[])
);

create policy company_memberships_insert_owner_only
on public.company_memberships
for insert
with check (public.has_company_role(company_id, array['owner']::public.app_role[]));

create policy company_memberships_update_owner_only
on public.company_memberships
for update
using (public.has_company_role(company_id, array['owner']::public.app_role[]))
with check (public.has_company_role(company_id, array['owner']::public.app_role[]));

create policy company_memberships_delete_owner_only
on public.company_memberships
for delete
using (public.has_company_role(company_id, array['owner']::public.app_role[]));

-- audit events policies
create policy audit_events_select_member
on public.audit_events
for select
using (public.is_company_member(company_id));

create policy audit_events_insert_member
on public.audit_events
for insert
to authenticated
with check (
  actor_user_id = auth.uid()
  and public.is_company_member(company_id)
);

revoke all on function public.create_company_with_owner(text, text) from public;
grant execute on function public.create_company_with_owner(text, text) to authenticated;
